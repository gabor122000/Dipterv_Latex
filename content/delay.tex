% =====================================================================
\chapter{A vezérlési késleltetés és a rendszer-reakcióidő elemzése}
% =====================================================================

\section{Bevezetés: A reakcióidő kritikus szerepe}

A dolgozatban bemutatott keretrendszer nem csak egy statikus 
eszköz, hanem egy aktív beleszól a rendszer elemek működésébe
Ezentúl vannak egyéb fizikai eszközök amik a felügyeleti rendszertől függetlenül üzemelnek. 

Energetikai rendszerek felügyeleténél a reakcióidő kritikus tényező, 
mert egy zárlat esetén rövid idő alatt nagyon nagy energiák szabadulnak fel. 
A keretrendszer célja, hogy a szoftveres energia 
allokációval a teljes keretet(\texttt{ALLOC\_MAX\_TOTAL}) úgy ossza fel,
hogy megelőzze a fizikai védelmi eszközök
(megszakítók)
leoldását. A rendszer versenyt fut az idővel: a szoftvernek gyorsabban 
kell beavatkoznia, mint ami a fizikai 
megszakító védelmén van beállítva leoldási időnek.
Ha a késleltetés túl nagy, a megszakítók leoldanak, mielőtt 
a szoftveres korlátozás érvénybe léphetne. 

\section{A vezérlés komponenseinek késleltetése }

Ahhoz, hogy a teljes rendszer reakcióideét (\(T_{total}\)) megértsük, 
fel kell bontanunk a teljes vezérlési hurkot az egyes komponensek 
által hozzáadott késleltetésekre. Egy túlterhelés észlelése 
és kezelése a következő lépésekből áll:

\begin{enumerate}
    \item \textbf{Mérés (\(T_{measure}\)):} Az \texttt{ESP8266} 
    árammérő szenzora (pl. SCT-013) fizikailag megméri az áramot. 
    Ez kb. valós időben törtnénik, ez a 
    késleltetés elhanyagolható.

    \item \textbf{Adat küldés (\(T_{publish}\)):} Az \texttt{ESP8266} 
    frissíti a mért értéket és elérhetővé teszi azt 
    a \texttt{/metrics} végponton. Ez elég szintén elég gyors, hogy valós idejűnek nevezzük .

    \item \textbf{Adatgyűjtés (\(T_{scrape}\)):} A Prometheus szerver a kontrol szerveren keresztül,
    gyűjti az adatokat. Mivel a kontrol szerverrel szinkronben kérdeznek, ezért szükséges mindekettőnek 
    a konfigurációjában (\texttt{scrape\_interval}) változót előre  és egységesen meghatározni, 
    ez időközönként lekérdezi a mérő végpontjának a \texttt{/metrics} URL-jét. 
    \emph{Ez a rendszer egyik legjelentősebb késleltetési tényezője.} 
    Ha egy tipikus 5 másodperces időközről beszélünk a mérés és a 
    Prometheus általi észlelés között, átlagosan 2.5, 
    rosszabb esetben 5 másodperc is eltelhet.

    \item \textbf{Adatfeldolgozás (\(T_{query}\)):} A 
    Kontroll Szerver lekérdezi az adatbázisból az 
    áramokat. 
    A lekérdezés gyors, viszont ez a lépés 
    is a Prometheus belső frissítési 
    ciklusától függ.

    \item \textbf{Döntéshozatal (\(T_{algo}\)):} A Python szerver 
    az adatokra lefuttatja a \texttt{max--min fair} 
    algoritmust. Az elosztást tagalaló fejezetben láttuk, hogy ennek bonyolultsága 
    \(O(n \log n)\), ez kis (\(n=3..10\)) fogyasztószám esetén 
    elhanyagolható.

    \item \textbf{Beavatkozás (\(T_{command}\)):} A szerver a számolás után 
    korlátokat küld a végpontoknak. Itt egyedül a hálózati késleltetések lépnek fel 
    (Wi-Fi, LAN).

    \item \textbf{Végrehajtás (\(T_{execute}\)):} Az \texttt{ESP8266} 
    fogadja a parancsot és a Modbus-os fizikai eszközök beállítják az autótöltő vagy egyéb eszköz maximális 
    áramát. Ez is egy gyors műveletnek számít.
\end{enumerate}

Így jön ki, hogy a következő lesz a teljes késleltetés: 
\begin{equation}
    T_{total} = T_{measure} + T_{publish} + T_{scrape} + T_{query} 
              + T_{algo} + T_{command} + T_{execute}
\end{equation}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.8\textwidth, keepaspectratio]{figures/Code_Generated_Image.png}
    \caption{késleltetés eloszlása} 
\end{figure}

\section{A fő késleltetési tényezők}

Az előző pont lánca jól mutatja, hogy a késleltetést nem az algoritmus
limitálja, hanem az adatgyűjtés architektúrája.

A teljes késleltetés nagy részét  (\(T_{total}\)) kettő tényező dominálja:
\begin{enumerate}
    \item \textbf{Prometheus Scrape Interval (\(T_{scrape}\)):} 
    Ez a rendszer "szívverése". A vezérlőhurok nem tud gyorsabban 
    reagálni, mint amilyen sűrűn friss adathoz jut. Ha ez az 
    érték 5 másodperc, a rendszer fizikailag "vakon" repül 
    5 másodpercig, és csak utólag értesül a korábbi eseményekről.
    
    \item \textbf{Hálózati késleltetés (\(T_{command}\)):} 
    A Wi-Fi-alapú kommunikáció további, változó hosszúságú (jitter) 
    késleltetést vihet a rendszerbe, terhelt vagy 
    zajos hálózati környezetben, ez különösen problémás hiszen
    nehéz számolni a dinamikusan változó késleltetéssel.
\end{enumerate}

Míg a hálózati késleltetés általában tíz-száz milliszekundum 
nagyságrendű, a \texttt{scrape\_interval} másodperces nagyságrendű alap beállítás szerint.
Viszont ezt lecsökkenthetjük akár 100ms-re is,
ez növeli a hálózati forgalmat és a szerver terhelését,
de jelentősen csökkenti a teljes késleltetést.
Így beállítható a megszakítók védelmi szintje ennél nagyobb értékre,
például 500ms-re. Így már nem kell aggódnunk, hogy a késleltetés miatt
a fizikai védelem leold.

\section{Védelmi beállítások késleltetések alapján}

A késleltetés számítása után lehetséges beállítani a védelem értékeit. 
A rendszerben kettő kvázi független védelmi szint létezik:

\begin{itemize}
    \item \textbf{1. Szoftveres Védelem (Allokáció):} 
    Ezt a \texttt{ALLOC\_MAX\_TOTAL} kerettel tudjuk beállítani. Célja a 
    \emph{komfort} és a \emph{hatékonyság} biztosítása, a keretek 
    a felhasználható teljesítmény folyamatos kihasználása és 
    a fizikai leoldások \emph{megelőzése}. Reakcióideje megfelelően pár száz milliszekundum (\(T_{total}\)).
    
    \item \textbf{2. Fizikai Védelem (Megszakító):} 
    Ezt a megszakító védelmének fizikai beállítása határozza meg. 
    Célja a hálózat fizikai védelme. 
    Reakcióideje azonnali viszont a védelemben késleltetést állítunk be, amit körülbelül
    a szoftveres érték kétszeresére állítunk.
\end{itemize}

A rendszer stabil működésének feltétele, hogy e két szint 
megfelelően legyen összehangolva, a kétszeres érték valószínűleg egy megfelelő mértékű
eltávolítás, ami enged helyet még a jitter-nek és egyéb hibáknak a vezeték nélküli hálózaton. 

\paragraph{Konfigurációs példa.}
Tegyük fel, hogy:
\begin{itemize}
    \item A szoftveres keret \(\texttt{ALLOC\_MAX\_TOTAL} = 90\,A\).
    \item A Prometheus \texttt{scrape\_interval} és a teljes hurok 
          késleltetése \(\textbf{\(T_{total}\) = 200\,ms}\).
    \item A csatlakoztatott eszközök (pl. autótöltők) képesek 
          200 milliszekundum alatt további 20\,A terhelést bekapcsolni 
          (pl. egy új autó csatlakozik).
    \item Ebben az esetben a fizikai megszakító védelmi beállítása 
            legyen legalább \(\textbf{\(T_{total}\) = 400\,ms}\).
\end{itemize}

Ebben az esetben az esetben megfelelő a kettő késleltetés távolsága, hogy ne történjen véletlen leoldás.
\begin{comment}
    
    \section{Következtetések}
    
    A keretrendszer sebességét nem a \texttt{max--min fair} 
    algoritmus bonyolultsága, hanem a \texttt{pull}-alapú 
    adatgyűjtési architektúra késleltetése határozza meg főként. 
    Ez a szoftveres késleltetés (\(T_{total}\)) a rendszer egyik 
    fő paramétere.
    
    A fizikai védelmi beállításokat a megszakító fizikai felületén 
    kötelezően ennek a szoftveres késleltetésnek a figyelembevételével 
    kell konfigurálni.
    A két védelmi szint között elegendő 
    headroom-ot kell hagyni, hogy a szoftveres allokációnak 
    legyen ideje reagálni a terhelésváltozásokra, mielőtt a fizikai 
    védelem szükségtelenül megszakítaná a szolgáltatást, a fizikai megszakítónak csak a
    hibák kivédésére szabad működnie. 
    A rendszer finomhangolásánál viszont fontos figyelembe venni az egyensúlyt
    a gyors adatgyűjtés, ezáltal gyors védelmi beállítás és a magas hálózati terhelés
    között.
    
    
    
\end{comment}