\chapter{Max--min fair (water-filling) elosztás}
\label{chap:max-min-fair}
\section{Elméleti háttér és cél}

\subsection{A szabályozási feladat és definíciók}

A dolgozat rendszerének fő feladata, hogy a rendelkezésre álló, 
korlátos villamos teljesítményt dinamikusan ossza el a fogyasztók (esetemben elektromos autótöltők) között úgy, 
hogy a hálózat fizikai védelme ne oldjon le, így a felhasználható áramon belül maradva maximalizáljuk 
a lehetőségeket.

Az elosztási algoritmus ismertetéséhez, szükséges definiálni a 
rendszerparamétereket, amik a vezérlő működésének alapját képzik. 
A rendszerben két védelem található:

\begin{itemize}
    \item Fizikai korlát (\texttt{BREAKER\_MAX\_TOTAL})
    \item Allokációs keret (\texttt{ALLOC\_MAX\_TOTAL})
\end{itemize}

A bemutatott \emph{max--min fair} algoritmus fő feladata tehát az, 
hogy a fogyasztók igényeit úgy elégítse ki, hogy összegük soha ne lépje át a 
szoftveres \texttt{ALLOC\_MAX\_TOTAL} keretet.

\subsection{Motiváció és cél}

A szimulált fogyasztók  áramigénye (\(d_i\)) időben változik. 
Adott egy globális, maximum áramérték \(\,B=\texttt{ALLOC\_MAX\_TOTAL}\,\) amperben, 
ennél a tényleges összáram nem lehet nagyobb. A cél egy olyan kiosztás \(\,a_i\) meghatározása, amely
(i) nem lépi túl az egyes igényeket (\(0\le a_i\le d_i\)),
(ii) a teljes kereten belül marad (\(\sum_i a_i \le B\)),
(iii) és \emph{fair} a kis igényűekkel szemben, azaz a kis igények teljesülnek először, a 
fennmaradó kapacitás pedig egyenlő alapról oszlik meg.

\subsection{Definíció (max--min fair)}
Egy \(\,a=(a_1,\dots,a_n)\) kiosztás \emph{max--min fair}, ha bármely más megengedett \(\,y\) esetén, 
ha létezik \(i\) úgy, hogy \(y_i > a_i\), akkor létezik \(j\) olyan, hogy \(a_j \le a_i\) és \(y_j < a_j\). 
Intuíció: csak a \emph{már kisebb} részesedésűek rovására lehet növelni bárki juttatását. \cite{leboudec_tutorial}

\subsection{Feltöltés (water-filling)}
A max--min fair kiosztás felírható egyetlen paraméterrel:
\begin{equation}
  a_i = \min\{\,d_i,\ \lambda\,\}, \qquad \text{ahol }\ \sum_{i=1}^n \min\{d_i,\lambda\} \;=\; B.
\end{equation}
A \(\lambda\) \emph{vízszint} úgy választandó, hogy a keret pont kiteljen (vagy ha \( \sum_i d_i < B\), 
akkor \(\lambda\ge \max_i d_i\), vagyis nincs korlát).

\subsection{Algoritmus és bonyolultság}
Gyakorlati, determinisztikus eljárás (progresszív töltés):
\begin{enumerate}
  \item Rendezzük az igényeket növekvő sorrendbe: \(d_{(1)} \le \dots \le d_{(n)}\).
  \item Iteráljuk \(k=1..n\): feltételezzük, hogy az első \(k\) igény teljesül (\(a_{(i)}=d_{(i)}\), \(i\le k\)), 
  és a maradék \(B_k = B - \sum_{i=1}^k d_{(i)}\) egyenlő szinten oszlik meg a még nyitott \(n-k\) elemre. 
  A jelölt vízszint: \(\lambda_k = B_k/(n-k)\).
  \item Ha \(\lambda_k \le d_{(k+1)}\), megtaláltuk a vízszintet: az összes hátralévő \(a_{(i)}=\lambda_k\) 
  (és a korábbiak \(d_{(i)}\)).
  \item Ha minden \(d_{(i)}\) teljesül és még marad keret, akkor nincs korlátozás: \(a_i=d_i\).
\end{enumerate}
A rendezés miatt az időbonyolultság \(O(n\log n)\). A megvalósított vezérlőben egy ekvivalens, 
iteratív \emph{progresszív} algoritmus fut, amely kis elemszámon szintén gyors és stabil.

\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{figures/Principle-of-Water-Filling-algorithm-76.png}
    \caption{Water-filling elve telekomunikációban. \cite{Slacik2021Sensors}}
    \label{fig:water-filling}
\end{figure}

\subsection{Tulajdonságok}
\begin{itemize}
  \item \textbf{Egyenlő szint elve:} a \(\lambda\) alatti igények teljes, a \(\lambda\) 
  felettiek \(\lambda\)-ig kapnak. Így a kis igényűek sosem szenvednek hátrányt.
  \item \textbf{Monotonitás:} ha a keret \(B\) nő, akkor \(\lambda\) nem csökken, és senki kiosztása nem csökken.
  \item \textbf{Határhelyzetek:} ha \(\sum_i d_i \le B\) → nincs cap (végtelen korlát). Ha \(B=0\) → minden \(a_i=0\).
\end{itemize}

\section{A vezérlőben alkalmazott megvalósítás}

\subsection{Kapcsolat a rendszer komponenseivel}
A vezérlő igényekből (\texttt{raw\_current}) számolja a limiteket a fenti elv szerint 
a \texttt{ALLOC\_MAX\_TOTAL} kereten. A \emph{megszakító} (breaker) logika ettől független, 
a \emph{mért, tényleges} áramhoz viszonyít (\texttt{BREAKER\_MAX\_TOTAL}, \texttt{BREAKER\_MIN\_TOTAL}) 
biztonsági rétegként.

\subsection{Példák}
\paragraph{Klasszikus példa.}
\(d=[10,10,100]\), \(B=90\) \(\Rightarrow\) \(a=[10,10,70]\) (a két kicsi teljesül, a maradék egy szinten oszlik meg).
\paragraph{Vegyes igények.}
\(d=[3,8,8,20]\), \(B=25\) \(\Rightarrow\) rendezve az első igény (3) teljesül, a maradék \(22\) 
három felé oszlik: \(a=[3,\,7.33,\,7.33,\,7.33]\) A.

\subsection{Implementációs részletek}
A limitek csak \(\pm 10^{-3}\) A változás felett frissülnek a fogyasztók felé (zajcsillapítás), 
a „nincs korlát” állapotot nagy \(\texttt{INF\_CAP}\) érték reprezentálja. Ha a nyers igény összeg a keret alá esik, 
a limitek feloldódnak.

\subsection{Alternatív allokációs stratégiák}
A globális keret elosztására több lehetőség is fennáll. A megfelelő algoritmus 
választása sokat tud javítani a rendszer hatékonyságán, ezért nagyon fontos. A \texttt{max--min fair} 
elv mellett kettő alternatívát találtam.

\paragraph{Proporcionális elosztás.}
Ennél a megközelítésnél minden fogyasztó a teljes igény (\(\sum_j d_j\)) arányában részesül a 
rendelkezésre álló keretből, amennyiben \(\sum_j d_j > B | B = Globál keret\). A kiosztás képlete: 
\( a_i = d_i \times (B / \sum_j d_j) \).
\begin{itemize}
    \item \emph{Példa:} Ha a keret \(B=90\)\,A, és az igények \(d=[50, 50, 100]\), 
    a teljes igény itt ekkor, \(\sum d_j = 200\)\,A. Az arányos kiosztás 
    \(a \approx [22.5, 22.5, 45]\)\,A lenne.
    \item \emph{Előnye:} Az egyik legegyszerűbb algoritmus.
    \item \emph{Hátrány:} Ez a stratégia a "nagy" fogyasztóknak 
    kedvez, és a kis igényűeket "éhezteti" (starvation).
\end{itemize}


\paragraph{Prioritásos (súlyozott) elosztás.}
Ebben az esetben minden fogyasztó kap \(w_i\) prioritási szintet 
(súlyt). Ha túlterhelés lépne fel a rendszer először a magasabb prioritású 
fogyasztókat elégíti ki, és a maradék keretből kapnak az alacsonyabb 
prioritású fogyasztók.
\begin{itemize}
    \item \emph{Előny:} Lehetővé teszi a "prémium" ügyfél fogalmát pl.: adott emberek 
    autótöltője mindig kap áramot.
    \item \emph{Hátrány:} Szintén bevezeti az "éheztetés" (starvation) problémáját, ahol egy 
    alacsony prioritású végpont akár soha nem kap erőforrást.
    A rendszer komplexitása nő, és a konfiguráció nehézkessé válik.
\end{itemize}


\paragraph{A választás indoklása.}
Az alternatívákkal szemben azért esett a választás a \textbf{max--min fair} elosztásra mert ez
biztosítja a legjobb egyensúlyt az egyszerűség és az igazságosság között. 
Motivációk között megfogalmazott pontokat teljesíti:

\begin{enumerate}
    \item \emph{Védi a kis fogyasztókat:} Garantálja, hogy aki keveset kér, az 
    megkapja, amíg a keret ezt egyáltalán lehetővé teszi. Ezzel elkerüli az 
    arányos elosztás fő problémáját az "éheztetést".
    \item \emph{Igazságos a nagy fogyasztók között:} A fennmaradó kapacitást 
    egyenlően osztja szét a nagy igényű fogyasztók között, anélkül, hogy 
    bonyolult prioritási problémákat kéne megoldani.
    \item \emph{Determinisztikus és stabil:} Az algoritmus viselkedése kiszámítható, 
    és könnyen implementálható.
\end{enumerate}
A tárgyalt tulajdonságok miatt esett a választás a Max--Min fair elvre.