\pagenumbering{roman}
\setcounter{page}{1}

\selecthungarian

%----------------------------------------------------------------------------
% Abstract in Hungarian
%----------------------------------------------------------------------------
\chapter*{Kivonat}\addcontentsline{toc}{chapter}{Kivonat}

Az elosztott villamosenergia-felhasználás (elektromos járműtöltők, lokális termelők, intelligens fogyasztók) gyors terjedése 
új követelményeket támaszt a villamos energia elosztó hálózattal szemben. A dolgozat egy olyan, nyílt forrású 
és konténerizált keretrendszert mutat be, ami kis költségű eszközöket (ESP8266 alapú mérő), egy Python-alapú vezérlőt, 
idősoros adatkezelést (Prometheus) és vizualizációt (Grafana) 
integrál egy egységes megoldásba. A cél egy könnyen reprodukálható és testreszabható rendszer megvalósítása, ami képes valós 
idejű felügyeletre és korlátos erőforrások kezelésére.

A javasolt architektúra a mérést és a vezérlést átlátható interfészeken mutatja. 
A végpontok áramértékeket exportálnak Prometheus-kompatibilis metrikákként. 
A Központi vezérlő (Python/Flask) REST API-n keresztül fogadja a méréseket, majd ipari környezetben elterjedt protokollon, 
Modbus/TCP-n keresztül hajt végre beavatkozásokat az energetikai eszközökön. 
A rendszer komponensei konténerekben futnak, fejlesztői környezetben Docker Compose biztosítja az orkesztrációt, 
míg nagyobb rendelkezésre állási igény esetén Kubernetes alkalmazható. 

A rendszer kulcseleme egy max-min fair allokációs elv, ami 
egy előre rögzített globális áramkeretet tartat be több fogyasztó között. 
Ez a kisebb igényeket preferálja, majd a fennmaradó kapacitást olyan módon osztja szét, hogy a fogyasztás összege  kiegyenlítődjön. 
Ez a megközelítés determinisztikus, egyszerűen paraméterezhető, és jól illeszthető valós idejű döntésekhez. 
A szabályozó a mérésekből származó idősoros adatokon dolgozik, és szabályok mentén 
(időablakok, prioritások, határértékek) állítja elő a beavatkozási parancsokat.

A megvalósítást szimulációs környezetben próbáltam. Itt ESP8266-alapú végpont gyűjtött terhelési adatokat valós idejű vizualizációval, 
miközben a kontrollkomponens dinamikusan korlátozta a fogyasztókat a megadott áramkeretre. A szimuláció determinisztikus bemenetekkel 
(küszöbök, ütemezések, vezérlési szkriptek) engedte meg különböző terhelési profilok és hibaesemények létrehozását, 
az algoritmus stabilitásának és működésének vizsgálatára. 
A tapasztalatok szerint a rendszer képes a keretek pontos követésére, 
a túllépések gyors csillapítására és az erőforrások igazságos elosztására.

A dolgozat hozzájárulásai a következők: 
(i) egységesített, Prometheus kompatibilis mérési interfész energetikai rendszerekhez 
(ii) max-min fair elosztást megvalósító vezérlő 
(iii) konténer-alapú referenciaimplementáció Docker Compose és Kubernetesben 
(iv) Grafana alapú üzemviteli és diagnosztikai irányítópultok
(v) reprodukálható tesztkörnyezet. 
A keretrendszer akár ipari célokra is alkalmas, költséghatékony alternatívát kínál a zárt, gyártóspecifikus megoldásokkal szemben.

\vfill
\selectenglish


%----------------------------------------------------------------------------
% Abstract in English
%----------------------------------------------------------------------------
\chapter*{Abstract}\addcontentsline{toc}{chapter}{Abstract}

The rapid spread of distributed electricity use (electric vehicle chargers, local producers, smart consumers)
places new demands on the electricity distribution network. The thesis presents an open source
and containerized framework that integrates low-cost devices (ESP8266-based meter), a Python-based controller,
time series data management (Prometheus) and visualization (Grafana)
into a single solution. The goal is to implement an easily reproducible and customizable system that is capable of real-time monitoring and managing limited resources.

The proposed architecture exposes measurement and control through transparent interfaces.
The endpoints export current values as Prometheus-compatible metrics.
The control server (Python/Flask) receives measurements via REST API, then performs commands on energy devices via Modbus/TCP, a protocol common in industrial environments.
The system components run in containers, Docker Compose provides orchestration in the development environment,
while Kubernetes can be used in cases of higher availability requirements.

The key element of the system is a max-min fair allocation principle, which
maintains a pre-set global power limit among multiple consumers.
This prefers smaller demands, then distributes the remaining capacity in such a way that the amount of consumption is balanced.
This approach is deterministic, easily parameterizable, and well suited to real-time decisions.
The controller works on time-series data from measurements and generates intervention commands based on rules
(time windows, priorities, limit values).
I tried the implementation in a simulation environment. Here, an ESP8266-based endpoint collected load data with real-time visualization,
while the control component dynamically limited the consumers to the specified power frame. The simulation allowed the creation of different load profiles 
and fault events with deterministic inputs
(thresholds, schedules, control scripts),
to test the stability and operation of the algorithm.
According to the experience, the system is able to accurately track the frames,
quickly mitigate overshoots, and fairly allocate resources.

The contributions of the thesis are as follows:
(i) a unified, Prometheus-compatible metering interface for energy systems
(ii) a controller implementing max-min fair allocation
(iii) a container-based reference implementation in Docker Compose and Kubernetes
(iv) Grafana-based operational and diagnostic dashboards
(v) a reproducible test environment.
The framework is suitable even for industrial purposes and offers a cost-effective alternative to closed, manufacturer-specific solutions.

\vfill
\selectthesislanguage

\newcounter{romanPage}
\setcounter{romanPage}{\value{page}}
\stepcounter{romanPage}